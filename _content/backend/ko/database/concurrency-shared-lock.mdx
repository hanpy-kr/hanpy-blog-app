---
deployment: true
category: Backend
title: 'Shared Lock'
summary: 'Shared Lock(공유 락)은 데이터베이스나 파일 시스템 등에서 동시성을 제어하기 위한 중요한 기법 중 하나로, 주로 데이터를 안전하게 읽기(read) 위한 용도로 사용됩니다.'
pageKey: Backend_Shared_Lock_ko
lng: KOR
publishedAt: 2025-01-31
---

# 공유 락(Shared Lock)

Shared Lock(공유 락)은 데이터베이스나 파일 시스템 등에서 동시성을 제어하기 위한 중요한 기법 중 하나로, 주로 데이터를 안전하게 읽기(read) 위한 용도로 사용됩니다. 여러 사용자(또는 트랜잭션)가 동시에 같은 데이터를 읽어야 할 때, 각 사용자에게 Shared Lock을 부여하면 서로 간섭 없이 자료를 확인할 수 있게 됩니다. 다음은 Shared Lock의 주요 특징을 살펴보겠습니다.



먼저, 데이터를 읽는 동안 다른 사용자도 같은 데이터에 대한 Shared Lock을 획득할 수 있습니다. 예를 들어, A 사용자가 표(table-1)의 특정 레코드를 읽고 있는 상황에서 B, C 사용자도 동시에 동일 레코드를 읽어야 한다면, A가 건 Shared Lock에 이어 B, C 역시 Shared Lock을 설정할 수 있습니다. 이렇게 여러 사용자가 겹쳐서 Shared Lock을 획득하면, 동일한 데이터를 동시에 읽어도 무결성이 훼손되지 않습니다.



두 번째로, Shared Lock이 걸린 데이터에는 배타(Exclusive) Lock을 설정할 수 없습니다. 예를 들어, A 사용자가 특정 레코드에 Shared Lock을 걸고 읽고 있을 때, B 사용자가 그 레코드를 수정하기 위해 Exclusive Lock을 획득하고자 해도, 기존 Shared Lock이 해제되기 전까지는 불가능합니다. 이는 <codeline>읽기는 여러 명이 동시에 해도 문제없지만, 누군가가 쓰기를 하려면 해당 리소스를 단독으로 소유해야 한다</codeline>는 원칙을 지키기 위함입니다.




또 한 가지 유의할 점은, Shared Lock 간에는 충돌이 없지만, Exclusive Lock과는 양립할 수 없다는 점입니다. 사용자 입장에서는 “읽기만 하는 순간”에는 성능이나 응답성이 좋아 보이지만, 실제로 수정이 필요한 상황에서 이미 여러 사람이 읽고 있다면 해당 작업이 대기 상태에 놓일 수 있다는 사실도 고려해야 합니다. 예컨대 10명이 같은 레코드를 동시에 읽는 중이라면, 이 레코드에 변경을 가하려는 사용자는 그 모든 Shared Lock이 해제될 때까지 기다려야 합니다.



결국 Shared Lock은 <codeline>읽기 연산은 병렬화하되, 쓰기 연산이 필요할 땐 단독 접근을 보장</codeline>하려는 목적을 잘 보여주는 개념입니다. 실무 환경에서는 Shared Lock과 Exclusive Lock(배타 락)을 적절히 조합해, 여러 트랜잭션이 동시에 읽기 작업을 하면서도 중요한 순간에는 충돌 없이 데이터를 갱신할 수 있도록 락을 제어합니다. 이러한 방식을 이해하고 설계하면, 시스템의 동시성을 높이면서도 데이터 무결성을 안정적으로 유지할 수 있게 됩니다.
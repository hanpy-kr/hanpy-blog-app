---
deployment: true
category: Backend
title: 'RedLock: Redis 기반 분산 락 구현과 실무 적용'
summary: 'RedLock은 Redis를 이용한 분산 락 알고리즘으로, 분산 환경에서 안전한 락을 보장하는 데 사용됩니다. 본 글에서는 RedLock의 원리, 구현 방법, 실무 적용 시 고려해야 할 점을 설명합니다.'
pageKey: redis_redlock_implementation
lng: KOR
publishedAt: 2025-04-12
---

# RedLock: Redis 기반 분산 락 구현과 실무 적용

## 1. 분산 환경에서의 락 문제

분산 시스템을 운영하다 보면 **여러 개의 노드가 동일한 자원에 접근**하는 상황이 발생합니다. 예를 들어, 쇼핑몰에서 한정 수량의 상품을 주문할 때, 여러 서버에서 동시에 재고를 차감하면 데이터 불일치가 발생할 수 있습니다.

<br />

이를 방지하기 위해 **분산 락(Distributed Lock)**이 필요합니다. Redis는 기본적으로 **SET NX**(Not Exists)와 **EX**(Expire) 옵션을 이용하여 **단일 노드 환경에서는 락을 쉽게 구현할 수 있지만**, 다중 노드 환경에서는 단순한 락으로는 여러 장애 상황(네트워크 분할, 노드 장애 등)에 취약할 수 있습니다.

<br />

이 문제를 해결하기 위해 등장한 알고리즘이 **RedLock**입니다.

---

## 2. RedLock이란?

**RedLock**은 Redis를 활용하여 **분산 환경에서 강력한 락을 제공**하기 위한 알고리즘입니다. Redis의 창시자인 **Salvatore Sanfilippo**가 제안했으며, 다중 Redis 노드를 활용하여 **높은 가용성과 안정성을 보장하는 락 시스템**을 구축할 수 있습니다.

### **RedLock의 핵심 개념**

- **다중 Redis 노드(3~5개)에서 락을 획득하여 분산 환경에서도 동기화 보장**
- **과반수 이상의 노드에서 락을 획득해야 유효한 락으로 간주**
- **노드 장애(Network Partition, Redis Crash) 상황에서도 동작 가능**

즉, **일부 Redis 노드가 다운되더라도 시스템 전체가 락을 유지할 수 있도록 설계**된 알고리즘입니다.

---

## 3. RedLock의 동작 원리

RedLock은 **5개의 Redis 노드(일반적으로 3개~5개)를 사용하여 락을 관리**합니다.  
락을 획득하는 과정은 다음과 같습니다.

### ** Step 1. 각 Redis 노드에서 락 시도**

- 클라이언트가 **각 Redis 노드에 같은 키를 **SET NX PX** 명령어**로 락을 시도합니다.
- **SET NX PX** 명령어는 락이 없을 경우에만 설정하며, 일정 시간이 지나면 자동으로 해제됩니다.

```sh title="redlock" showLineNumbers
SET my_lock_key random_token NX PX 10000
```

- my_lock_key: 락의 키
- random_token: 클라이언트가 생성한 고유한 값 (락 소유권 확인용)
- NX: 키가 존재하지 않을 때만 설정
- PX 10000: 10초 후 자동 해제

## ** Step 2. 과반수 이상의 Redis 노드에서 락 획득 확인**

클라이언트는 락을 요청한 후 응답 시간을 고려하여 빠르게 과반수 이상의 노드에서 락이 설정되었는지 확인합니다.
보통 3개의 노드 이상에서 락이 설정되면 유효한 락으로 간주합니다.
네트워크 지연을 방지하기 위해 타임아웃(락 요청 총 시간)은 TTL(락 만료 시간)의 절반 이하로 설정해야 합니다.

## ** Step 3. 락이 유효한지 확인 후 작업 수행**

과반수 이상의 노드에서 락을 획득했다면, 작업(예: DB 업데이트, 파일 수정 등)을 안전하게 실행합니다.

## ** Step 4. 락 해제**

작업이 끝나면 각 Redis 노드에서 락을 해제합니다.
락을 설정할 때 저장한 랜덤 토큰을 비교하여 해당 클라이언트만 락을 해제할 수 있도록 보장합니다.

```sh title="redlock" showLineNumbers
if redis.call("GET", my_lock_key) == random_token then
  redis.call("DEL", my_lock_key)
end
```

락을 설정한 클라이언트만 해당 키를 삭제할 수 있도록 검증하는 과정이 중요합니다.

---

## 4. RedLock의 구현 예제

### Node.js + Redis를 활용한 RedLock 구현

```
import { createClient } from "redis";
import Redlock from "redlock";

// 1. Redis 클라이언트 3개 생성
const redisClients = [
  createClient({ url: "redis://localhost:6379" }),
  createClient({ url: "redis://localhost:6380" }),
  createClient({ url: "redis://localhost:6381" }),
];

redisClients.forEach(client => client.connect());

// 2. Redlock 인스턴스 생성
const redlock = new Redlock(redisClients, {
  driftFactor: 0.01, // 클럭 드리프트 보정
  retryCount: 5, // 재시도 횟수
  retryDelay: 200, // 재시도 간격 (ms)
});

// 3. 락 획득 및 해제
async function criticalSection() {
  try {
    // 락 획득 (TTL 10초)
    const lock = await redlock.acquire(["resource_key"], 10000);
    console.log("락 획득 성공!");

    // 중요한 작업 수행
    await new Promise(resolve => setTimeout(resolve, 5000));

    // 락 해제
    await redlock.release(lock);
    console.log("락 해제 완료!");
  } catch (err) {
    console.error("락 획득 실패:", err);
  }
}

// 실행
criticalSection();
```

## 5. 실무 적용 시 고려할 점

1️⃣ 락을 무조건적으로 신뢰하면 안 됨

네트워크 장애나 Redis 서버 다운으로 인해 일부 노드에서 락이 유지될 가능성이 있음.
작업을 수행하기 전에 락을 다시 한 번 확인하는 로직이 필요.

2️⃣ TTL 설정 주의

락을 너무 짧게 설정하면, 작업이 완료되기 전에 락이 해제될 가능성이 있음.
반대로 너무 길면, 장애 발생 시 다른 프로세스가 락을 얻지 못할 수도 있음.

3️⃣ 비즈니스 로직과 연계

락 해제 전에 시스템 장애가 발생할 경우, 락이 유지될 수 있음.
락이 만료되었는지 주기적으로 확인하는 메커니즘을 추가해야 함.

6. 결론
   RedLock은 Redis를 활용한 강력한 분산 락 기법으로, 다중 노드 환경에서 데이터 정합성을 보장합니다.
   과반수 이상의 Redis 노드에서 락을 획득해야 유효한 락으로 간주하여, 네트워크 장애에도 안전성을 유지할 수 있습니다.
   실무 적용 시 TTL 설정, 락 검증, 장애 발생 시의 대응 전략을 신중하게 설계해야 합니다.
   RedLock을 올바르게 활용하면 고성능 분산 시스템에서도 안전한 동시성 제어를 구현할 수 있습니다.
   이를 통해 데이터 정합성을 유지하면서도 서비스의 확장성을 확보하는 것이 가능합니다. 🚀

## 참고

https://redis.io/docs/manual/patterns/distributed-locks/

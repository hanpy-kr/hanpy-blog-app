---
deployment: true
category: Backend
title: 'MongoDB B-tree'
summary: '동시성 제어는 다중 사용자 환경에서 데이터베이스나 공유 자원의 일관성과 무결성을 유지하기 위한 핵심 기술입니다.'
pageKey: backend_mongodb_btree_ko
lng: KOR
publishedAt: 2025-01-24
---

# MongoDB와 B-tree

B-Tree는 데이터베이스 시스템과 파일 시스템의 핵심 자료구조로, B-Tree는 대량의 데이터를 처리하는 데 있어 균형 잡힌 성능을 제공하기 때문에, MongoDB 같은 현대적 NoSQL 데이터베이스뿐만 아니라 전통적인 관계형 DB, 그리고 일부 파일 시스템 등 다양한 곳에서 폭넓게 쓰이고 있습니다. 이번 글에서는 B-Tree의 구조, 작동 원리, 그리고 데이터베이스에서의 활용에 대해 상세히 살펴보겠습니다.

---

## B-Tree란 무엇인가?

B-Tree(Balanced Tree)는 이진 탐색 트리를 일반화한 구조로, 여러 개의 자식을 가질 수 있는 균형 잡힌 트리입니다. 이 구조는 데이터를 정렬된 상태로 저장하며, 검색, 삽입, 삭제 연산의 복잡도를 <codeline>O(log n)</codeline>으로 유지합니다.

<br />

먼저 B-Tree의 탄생 배경을 잠깐 살펴보면, 디스크 I/O가 메모리 연산보다 훨씬 느리다는 점에 주목하게 됩니다. 많은 양의 데이터를 다루는 상황에서는 디스크 접근 횟수가 검색 속도를 좌우하게 마련이죠. B-Tree는 이러한 디스크 접근을 최소화하기 위해 설계된 트리 구조로, 이진 탐색 트리를 확장하여 한 노드가 여러 자식을 가질 수 있도록 만들었습니다. 각 노드가 최대한 많은 키(Key)와 자식 포인터를 포함하도록 함으로써, 트리의 높이를 낮게 유지하고 곧바로 목적지 노드에 도달할 수 있게 하는 셈입니다.

## B-Tree 구조

B-Tree의 가장 큰 특징 중 하나는 모든 리프 노드(leaf node)가 동일한 깊이에 존재한다는 점입니다. 덕분에 트리가 균형 상태를 유지할 수 있고, 검색·삽입·삭제 연산 모두 최악의 경우에도 O(log n)에 처리할 수 있습니다. 실제로 B-Tree 노드가 가득 차서 새로운 키를 삽입하지 못할 때는 ‘분할(Split)’ 과정을 거쳐 노드를 둘로 나눈 뒤, 그 중간 키를 부모 노드에 올려보내 트리의 높이가 불필요하게 늘어나는 것을 막습니다. 키를 삭제할 때도 유사한 방식으로 ‘병합(Merge)’을 통해 트리를 다시 균형 상태로 만드는 것이죠. 이러한 균형 유지 메커니즘 덕분에 대규모 데이터를 처리할 때도 꾸준히 좋은 검색·삽입·삭제 성능을 확보할 수 있습니다.

## B-Tree와 해시 테이블

많은 분들이 B-Tree를 공부하면서 “해시 테이블이 평균적으로 O(1)에 가까운 성능을 내는데, 굳이 B-Tree를 쓸 이유가 있을까?”라고 의문을 제기하곤 합니다. 해시 테이블은 분명 빠르고 간단한 구조이지만, <codeline>범위 검색(range query)</codeline>이나 정렬된 결과 조회에는 취약합니다. 반면 B-Tree는 내부적으로 키를 정렬된 상태로 유지하므로, 어떤 값 이상의 데이터만 찾고 싶다거나 특정 구간 내 데이터를 순회하고 싶을 때 매우 유리합니다. 게다가 B-Tree는 ‘한 노드에 여러 키와 자식 포인터’를 담는 구조를 활용해 디스크 접근 비용을 줄이고, 한 번의 I/O로 최대한 많은 정보를 가져올 수 있도록 최적화되어 있습니다.

## MongoDB와 B-Tree

MongoDB를 비롯해 대부분의 현대 데이터베이스는 B-Tree의 변형인 B+Tree를 인덱스 구조로 사용하고 있습니다. B+Tree에서는 리프 노드에만 실제 데이터를 저장하고, 리프 노드끼리는 연결 리스트 형태로 이어져 있기 때문에 범위 검색 시 한 리프 노드에서 옆 노드로 쉽게 넘어갈 수 있다는 점이 큰 장점입니다. 이는 결국 많은 양의 데이터를 특정 구간 또는 조건으로 조회하는 쿼리에서 뛰어난 성능을 보장합니다.

<br />

또한 디스크 기반으로 돌아가는 데이터베이스에서 B+Tree가 유리한 이유는, 한 노드(=디스크 블록)에 많은 키를 담아 한 번에 읽어오는 형태로 설계할 수 있기 때문입니다. 이런 방식을 통해 다른 자료구조에 비해 디스크 I/O가 훨씬 절약되고, 이는 곧 실질적인 검색 속도 향상으로 이어집니다.

<br />

물론 B-Tree(또는 B+Tree) 역시 만능은 아닙니다. 데이터 삽입과 삭제가 매우 빈번한 경우라면, 노드 분할과 병합이 자주 일어날 수 있고 그만큼 성능 저하가 발생할 수 있습니다. 또한 노드에 얼마나 많은 키를 담을지를 결정하는 ‘차수(Order)’ 설정이 중요한데, 차수가 너무 작으면 트리의 높이가 지나치게 높아지고, 너무 크면 자원 활용이 비효율적이 될 수 있습니다. 따라서 실제 운영 환경에서는 차수·노드 크기 등의 파라미터를 조정해 가며 최적의 지점을 찾는 과정이 필요합니다.

## 정리

정리하자면, B-Tree는 대규모 데이터를 다루면서도 검색과 갱신을 균형 잡힌 속도로 유지해야 하는 시스템에서 거의 표준으로 자리 잡은 자료구조입니다. 범위 쿼리가 중요한 환경에서는 사실상 B+Tree가 유일무이한 해법이 될 때가 많죠. 물론 특정 쿼리 패턴에서는 해시 인덱스가 나을 수도 있으니, 어떤 자료구조가 기반이 되어 있는지, 그리고 쿼리나 데이터 특성이 무엇인지를 종합적으로 고려해야 합니다.

<br />

개발자로 일하면서 데이터베이스 인덱스를 조정하거나 성능 튜닝을 해본 경험이 있으시다면, B-Tree에 대한 이해가 얼마나 중요한지 체감하셨을 겁니다. 단순히 키워드로만 알기보다는, B-Tree가 어떤 식으로 노드를 분할하고 병합하는지, 리프 노드는 어떻게 연결되는지 등 구체적인 작동 방식을 살펴보시면 인덱스 튜닝에도 큰 도움이 될 것입니다.

<br />

결국 B-Tree는 대량의 데이터를 효율적으로 관리할 수 있도록 고안된 자료구조로, 데이터베이스 성능을 좌우하는 핵심 열쇠라고 해도 과언이 아닙니다. MongoDB든 MySQL이든, 인덱스를 어떻게 구성하느냐에 따라 쿼리 시간이 수십 배 이상 차이 날 수 있는데, 이 모든 것은 B-Tree가 제공하는 균형 잡힌 탐색 구조 덕분입니다. 앞으로 인덱스를 최적화하거나 새로운 자료구조를 도입할 때, B-Tree의 원리와 장점을 한 번쯤 고민해보면 좋을 것 같습니다.

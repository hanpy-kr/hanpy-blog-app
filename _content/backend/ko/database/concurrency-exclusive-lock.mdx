---
deployment: true
category: Backend
title: 'Exclusive Lock'
summary: 'Exclusive Lock(배타 락)은 데이터에 대한 변경(Write) 연산을 수행할 때 다른 트랜잭션이나 사용자가 해당 데이터를 참조하거나 수정하지 못하도록 보장하는 잠금(Lock) 기법입니다.'
pageKey: Backend_Exclusive_Lock_ko
lng: KOR
publishedAt: 2025-02-01
---

# 배타 락(Exclusive Lock)

Exclusive Lock(배타 락)은 데이터에 대한 변경(Write) 연산을 수행할 때 다른 트랜잭션이나 사용자가 해당 데이터를 참조하거나 수정하지 못하도록 보장하는 잠금(Lock) 기법입니다. 읽기에만 사용되는 Shared Lock과 달리, Exclusive Lock은 오직 한 사용자(혹은 트랜잭션)만이 해당 자원을 독점하므로 ‘배타적(Exclusive)’이라는 이름이 붙었습니다. 다음은 Exclusive Lock의 특징과 활용 시 주의점을 알아보겠습니다.

<br />

첫째, 데이터를 변경하려면 Exclusive Lock이 필요합니다. 예컨대 특정 레코드에 대해 INSERT, UPDATE, DELETE 같은 조작을 수행해야 하는 상황이라면, 그 레코드를 안정적으로 수정하기 위해 Exclusive Lock을 걸어야 하죠. 이 잠금이 설정되면, 다른 트랜잭션에서 해당 데이터를 읽거나 쓸 때 충돌이 발생할 수 있으므로, 쓰기를 요청한 트랜잭션이 완료될 때까지(또는 롤백/커밋 등으로 Lock이 해제될 때까지) 대기 상태로 들어가야 합니다.

<br />

둘째, 배타 Lock이 걸린 리소스에는 다른 사용자가 접근할 수 없습니다. 예컨대 A 트랜잭션이 어떤 테이블의 특정 행에 Exclusive Lock을 설정했다면, B, C 등 다른 트랜잭션이 동일 행을 읽거나 수정하려고 해도 해당 락이 해제될 때까지 대기해야 합니다. 이는 “하나의 데이터에 한 시점에서는 딱 한 명만 쓰기 작업을 할 수 있다”는 배타성 원칙을 지키기 위한 것입니다.

<br />

셋째, Exclusive Lock은 이미 다른 트랜잭션에서 사용 중인 데이터(=다른 배타 Lock이 걸려 있는 자원)에 대해서는 설정할 수 없습니다. 즉, A 트랜잭션이 배타 락을 점유하고 있는 상태라면, 그 리소스에 중복으로 배타 락을 걸려는 시도는 거부됩니다. 동시에 Shared Lock 역시 획득할 수 없으므로, 읽기·쓰기에 모두 제약이 생기는 셈입니다.

<br />

마지막으로, 트랜잭션이 종료될 때까지 락이 유지된다는 점도 중요한 포인트입니다. 예를 들어 “select ... for update” 구문 같은 상황에서 데이터베이스는 해당 레코드에 Exclusive Lock을 건 뒤, 트랜잭션이 커밋 혹은 롤백될 때까지 배타 락을 해제하지 않습니다. 이로 인해 데이터 무결성이 지켜지지만, 장기간의 배타 락 보유는 다른 트랜잭션에 큰 병목을 유발할 수 있다는 점도 인지해야 합니다.

<br />

결국 Exclusive Lock은 데이터를 안전하게 수정하기 위해 필요한 필수적인 메커니즘입니다. 그러나 너무 오랫동안 락을 점유하거나, 불필요하게 광범위한 영역(예: 테이블 전체)에 배타 락이 걸리면, 시스템 전체 성능과 동시성에 악영향을 끼칠 수 있습니다. 따라서 필요한 범위·필요 시간만큼만 배타 락을 사용하고, 트랜잭션을 짧게 유지하는 등의 전략을 통해 데이터 정합성과 효율적인 동시성을 적절히 조화시키는 것이 중요합니다.
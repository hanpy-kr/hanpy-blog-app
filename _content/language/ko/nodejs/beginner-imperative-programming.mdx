---
deployment: true
category: Language
title: '명령형 프로그래밍(Imperative Programming)'
summary: '개발에서 자주 접하지만 막상 설명하기 어려운 명령형 프로그래밍. 그 개념과 예제를 통해 명확하게 정리해봅니다.'
pageKey: imperative_programming_guide
lng: KOR
publishedAt: 2025-07-20
---

# 명령형 프로그래밍(Imperative Programming)

프로그래밍 공부를 하다 보면 <codeline>명령형 프로그래밍</codeline> vs <codeline>선언형 프로그래밍</codeline>이라는 말을 자주 듣게 됩니다. 그리고 보통은 선언형이 더 "모던하고 우아하다"는 분위기로 흘러가죠. 하지만 명령형 프로그래밍은 여전히 모든 프로그래밍 패러다임의 뿌리라고 할 수 있습니다. 실제로 우리가 매일 쓰는 JavaScript, Python, Java, C 대부분이 명령형 스타일을 기본으로 하고 있고요.

<br />

이번 글에서는 명령형 프로그래밍(Imperative Programming)이란 무엇인지, 왜 여전히 중요한지, 실제 코드에서는 어떻게 보이는지 등을 알아봅시다.

---

## 명령형 프로그래밍이란?

명령형 프로그래밍은 말 그대로 "명령(instruction)"을 순서대로 내리는 방식의 프로그래밍으로 어떻게(**HOW**) 할지를 구체적으로 알려주는 방식입니다. "명령형"이라는 단어를 들었을 때, 군대처럼 '이렇게 해! 저렇게 해!' 하는 분위기를 상상하면 딱 맞다고 할 수 있습니다. 예를 들어 어떤 리스트를 정렬하거나 필터링한다고 할 때, 어떤 반복문을 사용할지, 어떤 조건문을 써야 할지를 **개발자가 직접 컨트롤**하는 방식입니다.

<br />

명령형 프로그래밍의 가장 큰 특징은 절차 중심의 사고방식을 기반으로 한다는 점입니다. 이 패러다임에서는 코드가 작성된 순서가 곧 실행 순서가 되며, 개발자는 프로그램이 어떤 흐름으로 동작할지를 명확히 통제할 수 있습니다. 명령형 프로그래밍에서는 함수 호출이나 분기, 반복 등의 흐름을 개발자가 직접 구성하고 결정하므로, 전체 코드의 실행 과정을 머릿속으로 순차적으로 시뮬레이션하기가 상대적으로 용이합니다. 이러한 특성은 특히 복잡한 로직을 하나씩 디버깅하거나 로우레벨 환경에서 실행 흐름을 정밀하게 조정해야 할 때 강력한 장점으로 작용합니다.

<br />

또한, 명령형 프로그래밍은 상태 변화(state mutation)를 기반으로 동작합니다. 변수의 값을 반복적으로 바꾸며 목적을 달성하는 방식이며, 이러한 방식은 메모리 상의 데이터를 직접 다루는 시스템 프로그래밍이나 알고리즘 구현에 매우 효과적입니다. 명령형 프로그래밍은 반복문과 조건문을 중심으로 작성되는 구조이며, 이는 컴퓨터가 처리하기에 매우 직관적인 형식입니다. <codeline>for</codeline>, <codeline>while</codeline>, <codeline>if</codeline> 같은 기본 문법 구조는 대부분의 프로그래밍 언어에 공통적으로 존재하며, 컴퓨터가 내부적으로 실행하는 로직과도 매우 밀접합니다. 실제로 머신 코드나 어셈블리 수준에서도 이러한 흐름 제어 방식이 유사하게 구현되어 있기 때문에, 명령형 스타일은 컴퓨터 입장에서도 해석하고 처리하기에 가장 친숙한 형식이라 할 수 있습니다. 이러한 점은 고성능이나 하드웨어 친화적인 프로그래밍에서 특히 유리하게 작용하며, 개발자에게도 로직의 흐름을 세밀하게 제어할 수 있는 수단을 제공합니다.

---

## 명령형 코드 예시 (JavaScript)

다음은 숫자 배열에서 짝수만 골라내는 명령형 방식의 코드입니다.

```javascript title="imperative programming" showLineNumbers
// 짝수 고르기
const numbers = [1, 2, 3, 4, 5, 6]
const evens = []
for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] % 2 === 0) {
    evens.push(numbers[i])
  }
}
console.log(evens) // [2, 4, 6]

// 문자열 뒤집기
const str = 'hello'
let reversed = ''
for (let i = str.length - 1; i >= 0; i--) {
  reversed += str[i]
}
console.log(reversed) // "olleh"

// 중복 제거
const items = [1, 2, 2, 3, 4, 4, 5]
const uniqueItems = []
for (let i = 0; i < items.length; i++) {
  if (!uniqueItems.includes(items[i])) {
    uniqueItems.push(items[i])
  }
}
console.log(uniqueItems) // [1, 2, 3, 4, 5]

// map을 명령형으로 구현
const numbers = [1, 2, 3, 4]
const doubled = []
for (let i = 0; i < numbers.length; i++) {
  doubled.push(numbers[i] * 2)
}
console.log(doubled) // [2, 4, 6, 8]
```

위 예시들은 모두 "어떻게"라는 절차를 개발자가 직접 컨트롤하는 방식으로, 명령형 프로그래밍의 대표적인 패턴들입니다. 이러한 방식은 로직의 흐름과 데이터 변경 과정을 보다 세밀하게 추적할 수 있다는 장점이 있지만, 로직이 복잡해질수록 유지보수가 어려워질 수 있습니다.

---

## 선언형 프로그래밍과 비교

같은 기능을 선언형 스타일로 바꾸면 이렇게 됩니다:

```javascript title="declarative programming" showLineNumbers
// 짝수 고르기 (선언형)
const numbers = [1, 2, 3, 4, 5, 6]
const evens = numbers.filter((num) => num % 2 === 0)
console.log(evens) // [2, 4, 6]

// 문자열 뒤집기 (선언형)
const str = 'hello'
const reversed = str.split('').reverse().join('')
console.log(reversed) // "olleh"

// 중복 제거 (선언형)
const items = [1, 2, 2, 3, 4, 4, 5]
const uniqueItems = [...new Set(items)]
console.log(uniqueItems) // [1, 2, 3, 4, 5]

// map 구현 (선언형)
const numbers = [1, 2, 3, 4]
const doubled = numbers.map((num) => num * 2)
console.log(doubled) // [2, 4, 6, 8]
```

선언형 스타일은 코드가 간결하고 의도를 명확하게 표현할 수 있어, 가독성과 유지보수 측면에서 유리한 경우가 많습니다. 다만 내부 동작 원리를 파악하거나, 성능 최적화가 필요한 경우에는 명령형 방식이 더 효과적일 수도 있습니다.

<br />

이 스타일은 '무엇을 하고 싶은지'만 명시하면 됩니다. "나는 짝수만 필요해"라고 말하는 거죠. 어떻게 그걸 하는지는 JavaScript 내부 <codeline>filter</codeline> 함수가 알아서 처리합니다.

---

## 명령형 스타일이 유리한 경우

현대 개발 트렌드에서는 선언형 프로그래밍이 가독성과 추상화 측면에서 높은 평가를 받으며 널리 채택되고 있지만, 명령형 스타일이 오히려 더 적합한 영역도 분명히 존재합니다. 특히 알고리즘 구현에서는 그 특성이 더욱 두드러집니다. 예를 들어 버블 정렬, DFS(깊이 우선 탐색), BFS(너비 우선 탐색)와 같은 로직은 데이터의 상태를 반복적으로 갱신하고 제어 흐름을 미세하게 조정해야 하기 때문에, 명령형 접근 방식이 훨씬 직관적이며 성능 면에서도 유리합니다. 이러한 알고리즘은 중간 상태를 직접 조작하는 것이 핵심이기 때문에, 절차적 로직을 상세히 기술할 수 있는 명령형 프로그래밍이 자연스럽게 어울립니다.

<br />

또한, 성능을 정밀하게 튜닝해야 하는 시나리오에서도 명령형 코드는 효과적입니다. 선언형 함수인 <codeline>map</codeline>이나 <codeline>filter</codeline>는 내부적으로 반복자와 새로운 배열을 생성하는 과정이 포함되어 있어, 반복 호출 시 메모리 사용량과 함수 호출 오버헤드가 누적될 수 있습니다. 반면, <codeline>for</codeline> 루프를 직접 사용하는 명령형 방식은 불필요한 추상화 없이 최소 연산만 수행할 수 있기 때문에, 고성능이 요구되는 로우레벨 환경이나 대량의 데이터를 처리할 때 더 적합한 선택이 될 수 있습니다.

<br />

뿐만 아니라, 운영체제나 임베디드 시스템, 하드웨어 제어와 같은 저수준 프로그래밍 분야에서는 명령형 프로그래밍이 사실상 표준입니다. 메모리 관리, 레지스터 제어, 인터럽트 핸들링 등 세밀한 리소스 제어가 필요한 작업은 선언형 추상화로는 표현하기 어려운 경우가 많기 때문입니다. 마지막으로, 복잡한 로직의 디버깅이나 상태 기반 추적이 필요한 상황에서도 명령형 코드는 실행 순서와 상태 변화를 명확히 드러내기 때문에 문제 원인 분석과 흐름 이해에 더 유리한 구조를 제공합니다. 이러한 점들로 미루어 보았을 때, 선언형과 명령형은 경쟁 관계라기보다는 상호 보완적인 도구로 바라보는 것이 더 바람직하며, 상황에 따라 적절하게 선택하고 활용할 수 있는 실용적 관점이 중요합니다.

---

## 명령형 프로그래밍의 단점

명령형 프로그래밍은 절차적 흐름과 상태 변경을 직접 제어할 수 있다는 점에서 많은 장점을 지니지만, 그에 못지않게 명확한 한계와 단점도 존재합니다. 가장 대표적인 문제는 가독성 저하입니다. 코드가 복잡해질수록 변수의 상태 변화, 조건 분기, 반복문 등이 얽히게 되는데, 이로 인해 코드의 흐름을 한눈에 파악하기 어려워지고 디버깅 또한 까다로워집니다. 특히 여러 기능을 하나의 절차 안에 모두 구현하는 경우, 단일 책임 원칙(SRP)이 무너져 코드의 재사용성과 유지보수성도 크게 떨어지게 됩니다.

<br />

또한 명령형 스타일은 함수형 프로그래밍이 강조하는 불변성(immutability)이나 순수 함수(pure function) 개념과는 거리가 멀기 때문에, 병렬 처리나 테스트 자동화 같은 작업에도 불리할 수 있습니다. 상태 변화가 코드 전반에 걸쳐 퍼져 있다면, 특정 동작의 원인이나 결과를 추적하기가 어려워지며, 이는 결과적으로 프로그램의 신뢰성과 안정성에도 영향을 줄 수 있습니다. 대표적인 예로 자주 언급되는 React는 UI를 선언형 방식으로 구성할 수 있도록 도와주는 프레임워크입니다. 예전에는 DOM을 직접 조작하면서 "이 버튼을 클릭하면 이 HTML 요소를 이렇게 바꿔라"는 식으로 명령형 코드를 작성해야 했습니다. 하지만 React에서는 마치 "현재 상태가 이렇다면, 화면은 이렇게 보여줘"라고 선언하듯 작성합니다. 예를 들어, <codeline>\{isLoggedIn ? '로그아웃' : '로그인'\}</codeline>처럼 상태에 따라 UI를 자동으로 조정하게 만들 수 있어서 훨씬 직관적이고 유지보수가 쉬워집니다.

<br />

또한 JavaScript의 고차 함수인 <codeline>map</codeline>, <codeline>filter</codeline>, <codeline>reduce</codeline> 등은 배열을 반복하거나 가공할 때 반복문을 직접 쓰는 대신, 무엇을 하고 싶은지 함수로 표현할 수 있게 해줍니다. 예를 들어 짝수만 뽑고 싶을 때는 <codeline>numbers.filter(n => n % 2 === 0)</codeline>처럼 작성할 수 있고, 이를 통해 코드가 더 간결하고 의도가 명확해집니다. 반복문보다 로직 분리가 잘 되어 있고, 가독성도 훨씬 좋아집니다.

<br />

마지막으로 Redux는 상태 관리에서 명령형의 단점을 보완하기 위해 나온 구조입니다. 일반적으로 명령형 코드에서는 상태를 여기저기에서 바꾸기 때문에 어떤 코드가 어떤 상태를 만들었는지 추적하기가 어렵습니다. 하지만 Redux는 상태를 오직 '하나의 흐름(one-way data flow)'으로만 바꾸게 하고, 이전 상태와 다음 상태를 기록하며, 상태 변경은 반드시 순수 함수인 <codeline>reducer</codeline>를 통해서만 이루어지게 강제합니다. 이로 인해 상태 변화의 흐름이 투명해지고, 예측 가능한 구조를 유지할 수 있습니다.

<br />

이러한 도구들과 방식들은 모두 명령형의 장점은 유지하면서도, 복잡도를 낮추고 안정성을 높이는 데에 중점을 둡니다. 선언형과 함수형 패러다임의 장점을 차용함으로써 현대 애플리케이션의 요구에 더 잘 맞는 형태로 발전하고 있는 것이죠.

---

## 정리

명령형 프로그래밍은 ‘어떻게’ 해결할지를 명확히 지시하며, 변수와 상태 변화를 중심으로 절차적 흐름을 직접 제어하는 방식입니다. 성능과 세밀한 제어에는 강점을 가지지만, 가독성과 추상화 측면에서는 한계가 있습니다. 따라서 현대 개발에서는 선언형 스타일이 선호되지만, 명령형 프로그래밍에 대한 이해가 있어야 상황에 따라 적절한 선택과 균형 있는 설계를 할 수 있습니다.

---

## 참고

- [MDN - JavaScript Imperative Programming](https://developer.mozilla.org/en-US/docs/Glossary/Imperative)
- [Wikipedia - Imperative Programming](https://en.wikipedia.org/wiki/Imperative_programming)

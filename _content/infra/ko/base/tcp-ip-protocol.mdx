---
deployment: true
category: Backend
title: 'TCP/IP protocol'
summary: '인터넷 통신의 핵심 기반인 TCP/IP 프로토콜의 구조와 계층별 동작 원리, 그리고 TCP 상태 전이를 통해 어떻게 안정적 연결과 종료가 이루어지는지를 살펴봅니다.'
pageKey: tcp_ip_protocol_working
lng: KOR
publishedAt: 2025-06-28
---

# TCP/IP protocol

우리는 일반적으로 인터넷으로 메일을 보내고, API 요청을 날리고, 스트리밍 영상을 자주 봅니다. 이러한 일상적인 과정들이 가능하려면 보이지 않는 그물망 같은 프로토콜이 작동하고 있어야 합니다. 바로 그 중심에 **TCP/IP**가 있습니다. TCP/IP 프로토콜은 개념적으로 다소 추상적일 수 있지만, 이를 일상생활에서 접하는 택배 시스템에 비유하면 훨씬 이해가 쉬워집니다.

<br />

**TCP**는 택배를 실제로 배달하는 **택배회사**에 해당합니다. 단순히 물건을 보내는 것이 아니라, 고객이 원하는 시간과 장소에 정확히, 그리고 순서대로 물건이 도착하도록 신경을 씁니다. 만약 어떤 물건이 손상되었거나 빠졌다면 다시 보내주기도 하죠. 마찬가지로 TCP는 데이터 전송 시 순서를 지키고, 손실되면 재전송하고, 도착 여부를 확인하면서 신뢰성 있는 통신을 보장하는 역할을 합니다.

<br />

다음으로, **IP**는 길을 안내해주는 **지도 앱**이나 **내비게이션**처럼 동작합니다. 물건(데이터)이 목적지까지 어떻게 가야 할지를 결정합니다. 어느 중간 경로(라우터)를 거쳐야 가장 효율적으로 갈 수 있을지를 계산하고 안내합니다. IP는 이러한 **주소 기반 라우팅**을 담당하며, 데이터를 목적지 IP 주소로 정확히 전달합니다.

<br />

IP에 포함된 **포트 번호**는 아파트의 **호수**에 비유할 수 있습니다. 아파트 단지는 하나의 IP 주소이고, 그 안에 여러 세대(서비스나 애플리케이션)가 존재한다고 보면 됩니다. 택배기사가 특정 아파트까지 도착하더라도 정확히 몇 동 몇 호로 가야 정확한 사람에게 전달되는 것처럼, TCP/IP에서는 포트 번호를 통해 어떤 응용 프로그램에게 데이터를 넘겨줘야 할지를 구분합니다.

<br />

마지막으로, **DNS**(Domain Name System)는 우리가 기억하기 쉬운 **주소록**입니다. 예를 들어, 우리가 'google.com'이라는 이름만 알고 있을 뿐 그 실제 위치인 IP 주소는 모르더라도, DNS가 그 이름을 해당 IP 주소로 변환해줍니다. 이는 마치 "이름만 알고 있는 친구의 실제 집 주소를 전화번호부에서 찾아주는 과정"과 같습니다.

<br />

요약하자면, 인터넷에서 데이터를 주고받는 과정은 마치 실물 택배가 사람 손을 거쳐 정확히 배달되는 과정과 유사합니다. DNS가 주소를 찾고, IP가 길을 안내하고, TCP가 물건을 정확히 배달하고, 포트 번호가 수령인을 구분해줍니다. 이처럼 TCP/IP는 우리 눈에는 보이지 않지만, 데이터라는 '소포'를 완벽하게 전달하기 위해 정교하게 협력하고 있는 **네트워크 물류 시스템**이라 할 수 있습니다. 이번 글에서는 인터넷 통신의 기본이 되는 **TCP/IP 프로토콜의 구조와 동작 원리**, 그리고 **TCP 연결 상태 전이**를 통해 **어떻게 안정적으로 데이터를 주고받고, 연결을 종료하는지**까지 알아봅시다.

---

## TCP/IP 4계층 구조와 그 역할

TCP/IP는 단일한 하나의 프로토콜이 아니라, 서로 다른 역할을 가진 여러 프로토콜이 층을 이루며 쌓여 있는 구조입니다. 이를 **계층 구조**(layered architecture)라고 부르는데, 이는 마치 하나의 배송 시스템이 주문, 포장, 운송, 배송 확인 같은 단계를 거치는 것처럼, 복잡한 네트워크 통신을 역할별로 나눠 관리하기 위해 설계된 구조입니다.

<br />

계층 구조의 장점은 분명합니다. 각 계층은 자신의 역할에만 집중하고, 다른 계층의 동작 방식은 몰라도 됩니다. 덕분에 설계가 단순해지고, 유지보수와 확장도 쉬워집니다.

### 1. 응용 계층 (Application Layer)

사용자가 직접 마주하는 계층입니다. 우리가 웹 브라우저에서 URL을 입력하거나 메신저로 메시지를 보낼 때, 그 요청은 이 계층에서 시작됩니다.

- 대표적인 프로토콜: HTTP(웹), FTP(파일 전송), SMTP(이메일), DNS(도메인 이름 변환)

### 2. 전송 계층 (Transport Layer)

응용 계층의 데이터를 신뢰성 있게 혹은 빠르게 전송할지를 결정하는 계층으로 대표적인 프로토콜로는 TCP, UDP가 있습니다. TCP는 연결을 맺고 순서를 보장하며 전송하고, UDP는 빠르게 전송하지만 신뢰성은 보장하지 않습니다. 또한 포트 번호를 통해 어느 앱과 통신하는지도 구분합니다.

### 3. 인터넷 계층 (Internet Layer)

데이터를 어디로 보내야 하는지, 즉 목적지를 찾아가는 일을 합니다. 대표적인 프로토콜로는 IP, ICMP, ARP가 있습니다. IP 주소를 기반으로 데이터를 분할하고, 라우터를 통해 최적 경로를 선택합니다.

### 4. 네트워크 인터페이스 계층 (Network Interface Layer)

실제 물리 네트워크(예: 이더넷, 와이파이)를 통해 데이터를 전기 신호나 무선 신호로 변환해 전송하는 역할을 합니다. 데이터가 물리적으로 송수신되는 가장 아래 계층입니다. 이 계층에서는 MAC 주소와 같은 하드웨어 주소가 사용됩니다.

<br />

TCP/IP는 "사람 → 앱 → 운영체제 → 네트워크 카드 → 케이블 → 인터넷"으로 이어지는 데이터 전달 경로를, 단계별로 나누고 책임을 분리해 설계한 것입니다. 이렇게 계층화된 덕분에, 예를 들어 우리가 HTTP를 새로 개선하더라도, TCP나 IP의 동작 방식은 전혀 건드릴 필요 없이 독립적으로 개선할 수 있는 거죠.

---

## TCP/IP는 데이터 전송 과정

우리는 매일 웹사이트에 접속합니다. 예를 들어 웹 브라우저 주소창에 https://example.com을 입력하고 엔터를 누르는 순간, 화면에는 웹 페이지가 로드되죠. 겉으로는 단순한 동작처럼 보이지만, 이 짧은 순간 동안 인터넷 아래에서는 수많은 복잡한 과정이 일어나고 있습니다. 이제 그 과정을 단계별로 하나하나 따라가 보겠습니다.

### 1. DNS 질의 - 이름을 주소로 바꾸는 과정

사람은 example.com 같은 이름을 기억하기 쉬워하지만, 컴퓨터는 숫자로 된 IP 주소를 사용해 통신합니다. 그래서 먼저 **도메인 이름을 IP 주소로 변환하는 과정**(DNS 질의)이 필요합니다.

- 브라우저는 먼저, example.com에 대응하는 IP 주소가 무엇인지 알아내야 합니다.
- 이를 위해 DNS 서버에 질의를 보내면 IP 주소를 리턴해 줍니다. (예: example.com → 93.184.216.34)

DNS는 인터넷의 전화번호부와 같아서, 도메인 이름에 해당하는 IP 주소를 알려주는 역할을 합니다.

### 2. TCP 연결 수립 - 신뢰할 수 있는 통신 준비

이제 IP 주소를 알게 되었으니, 본격적인 통신을 시작할 준비를 해야 합니다. 여기서 **TCP**(Transmission Control Protocol)의 역할이 중요해집니다. TCP는 신뢰할 수 있는 통신을 위해 반드시 연결을 먼저 맺는 방식을 사용합니다. 이때 사용하는 것이 바로 3-way handshake입니다.

- 클라이언트가 서버에 <codeline>SYN</codeline> 요청 전송
- 서버가 <codeline>SYN-ACK</codeline>으로 응답
- 클라이언트가 <codeline>ACK</codeline>으로 응답하면서 연결이 수립

이렇게 세 번의 신호 교환을 통해 **"양측이 통신할 준비가 되었다"**는 사실을 서로 확인하고 나서야 데이터 전송이 시작됩니다.

### 3. HTTP 요청 전송 - 웹 페이지를 요청

이제 연결이 되었으니, 웹 페이지 데이터를 요청하는 단계입니다. 사용자가 입력한 주소를 기반으로 웹 브라우저는 아래와 같은 형태의 HTTP 요청 메시지를 생성합니다.

```bash title="http"
  GET / HTTP/1.1
  Host: example.com
```

이 요청은 응용 계층의 HTTP 프로토콜을 따라 구성되며, TCP 위에 실려 전송됩니다. 여기서 중요한 건, 사용자는 "주소 입력"만 했지만, 실제로는 이러한 프로토콜 메시지가 자동으로 생성된다는 점입니다.

### 4. IP 패킷으로 포장

HTTP 요청 메시지가 만들어지면, 이제 이를 IP 패킷의 형태로 감싸는 작업, 즉 **캡슐화**(encapsulation)가 진행됩니다. 전송 계층(TCP)은 데이터를 세그먼트(segment)로 나누고 인터넷 계층(IP)은 세그먼트를 패킷(packet)으로 감쌉니다. 이 IP 패킷에는 출발지와 목적지 IP 주소가 포함되게 됩니다. 이제 이 패킷은 라우터를 통해 최적 경로를 따라 목적지 서버로 전송되게 됩니다. 이 과정은 지도 앱이 길을 찾아주는 것처럼, 라우터가 목적지에 도달할 수 있도록 중간중간 방향을 안내합니다.

### 5. MAC 주소 기반 전송 - 물리적 네트워크를 통한 실제 전달

마지막 단계는 물리적으로 데이터가 전달되는 구간입니다. IP 주소를 기반으로 한 경로 탐색이 끝난 후, 해당 패킷은 로컬 네트워크나 이더넷을 통해 전송됩니다.

- 이때 사용하는 주소는 MAC 주소, 즉 네트워크 카드의 고유한 하드웨어 주소입니다.
- 네트워크 인터페이스 계층에서 IP 패킷은 프레임(frame)으로 감싸지고, MAC 주소를 포함해 송신됩니다.

이 과정을 통해 데이터는 전기적 신호 혹은 무선 신호로 바뀌어 진짜로 케이블을 타고 혹은 와이파이를 통해 이동하게 됩니다.

<br />

![image](https://resource.han-py.com/blog/infra/tcp:ip-data-flow.png)

<br />

정리하면, 브라우저에 주소를 입력하는 단순한 행동은 실제로 아래와 같은 일련의 네트워크 과정을 거칩니다.

1. 사람이 이해할 수 있는 도메인 이름을 IP 주소로 바꾸고 (DNS)
2. 서로 통신할 준비를 하고 (TCP 연결)
3. 서버에게 웹 페이지를 요청하고 (HTTP 요청)
4. 요청을 목적지까지 정확히 보내기 위해 패킷으로 포장하고 (IP)
5. 실제 케이블이나 와이파이를 통해 물리적으로 데이터를 전달합니다 (MAC)

이 모든 과정은 1초도 안 되는 짧은 시간 동안 일어나며, TCP/IP 프로토콜이 각 계층에서 자신의 역할을 충실히 수행해줌으로써 가능한 일입니다.

---

## TCP는 어떻게 연결을 유지하고 종료할까? (상태 전이)

TCP는 단순히 데이터를 주고받는 것을 넘어서, **연결의 시작부터 종료까지 모든 상태를 엄격하게 관리**합니다. 이러한 상태 기반 설계 덕분에 TCP는 **신뢰성 있는 통신, 순서 보장, 오류 복구** 등을 안정적으로 제공할 수 있습니다. 다음은 TCP 연결이 **유지되고 종료되는 과정에서 거치는 주요 상태들**입니다.

- <codeline>ESTABLISHED</codeline>: 클라이언트와 서버 간의 3-way handshake가
  완료된 상태입니다. 이 시점부터 양측은 자유롭게 데이터를 송수신할 수 있습니다.
- <codeline>FIN_WAIT_1</codeline> → <codeline>FIN_WAIT_2</codeline>: 연결 종료를
  먼저 요청한 쪽(능동 종료자)이 진입하는 상태입니다. FIN을 보낸 후 상대의 ACK를
  기다리며 <codeline>FIN_WAIT_1</codeline> 상태에 있고, ACK를 받으면 <codeline>
    FIN_WAIT_2
  </codeline>로 전이됩니다. 이후 상대방의 FIN을 기다리게 됩니다.
- <codeline>CLOSE_WAIT</codeline> → <codeline>LAST_ACK</codeline>:
  상대방으로부터 FIN을 먼저 받은 쪽(수동 종료자)이 진입하는 상태입니다. FIN을
  수신하면 <codeline>CLOSE_WAIT</codeline> 상태가 되며, 자신이 처리해야 할
  마무리 작업(데이터 전송 등)을 끝낸 후 FIN을 보냅니다. 그 후 상대의 ACK를
  기다리며 <codeline>LAST_ACK</codeline> 상태가 됩니다.
- <codeline>TIME_WAIT</codeline>: 양쪽 모두 FIN과 ACK를 주고받고 세션이
  논리적으로 종료되었음을 확인한 후, 지연된 패킷이나 재전송된 FIN에 대응하기
  위해 일정 시간 (2 \* MSL) 동안 대기합니다. 이 상태는 능동적으로 종료를 시작한
  쪽에서 발생하며, 동일한 포트 번호 재사용으로 인한 세션 충돌을 방지합니다.
- <codeline>CLOSED</codeline>: 모든 종료 과정이 끝난 후 세션 정보가 완전히
  소멸된 상태입니다. 연결이 처음 시작되기 전 또는 종료된 이후 모두 이
  상태입니다.

이러한 TCP의 상태 전이 모델은 단순히 '끊는다'는 것이 아니라, **데이터 유실 방지, 세션 중복 방지, 예외 상황 대비**까지 고려된 정교한 연결 종료 프로토콜입니다. 특히 <codeline>TIME_WAIT</codeline>은 종종 불필요해 보이지만, 실제로는 **지연 네트워크 환경이나 비정상 종료 대응에 꼭 필요한 안정성 장치**입니다.

---

## TCP/IP가 제공하는 주요 기능 정리

- **패킷 분할 및 재조립**
- **흐름 제어 / 혼잡 제어**
- **순서 보장 및 재전송**
- **에러 검출 및 응답 보장**

---

## 마무리

TCP/IP는 단순히 '데이터를 보내는 방법'이 아닙니다. **복잡한 네트워크 환경에서도 신뢰성 있는 통신이 가능하도록 설계된, 철저히 구조화된 시스템**입니다. 특히 TCP의 상태 전이 모델은 현대 인터넷 서비스의 안정성과 복원력을 지탱하는 핵심 중 하나라고 할 수 있습니다.

<br />

마지막으로, TCP/IP 모델과 OSI 모델은 네트워크 통신을 설명하기 위한 구조지만, 설계 목적과 사용 방식이 다릅니다. TCP/IP 모델은 실제 인터넷을 설계하고 동작시키기 위해 만들어진 현실적인 구현 모델입니다. 현재 우리가 사용하는 인터넷, 웹, 이메일 등 대부분의 통신은 이 TCP/IP 모델을 따릅니다. 계층 수는 총 4개이며, 응용 계층에서는 HTTP, SMTP 등이 동작하고, 전송 계층에서는 TCP/UDP가, 인터넷 계층에서는 IP, 데이터 링크 및 물리 계층은 하드웨어 기반 네트워크와 연결됩니다. 계층 간 역할이 통합되어 있어 실제 구현에 최적화된 구조입니다.

<br />

반면 **OSI 모델**(Open Systems Interconnection)은 다양한 네트워크 장비와 프로토콜 간 호환성과 이해를 돕기 위한 이론적인 표준 모델입니다. 총 7개의 계층으로 구성되어 있고, 각 계층은 전송, 표현, 세션처럼 세분화된 기능을 담당합니다. 이는 실제 구현보다는 교육, 설계 가이드라인, 프로토콜 분석에 주로 사용됩니다.

<br />

가장 큰 차이는 TCP/IP는 실제 동작하는 인터넷을 위한 구조인 반면, OSI는 이상적인 분리를 통한 이해 중심의 구조라는 점입니다. TCP/IP는 간결하고 현실적이며, OSI는 구조적으로 정밀하고 이상적인 형태를 추구합니다. 두 모델은 목적이 다르기 때문에 계층 수, 구성 방식, 적용 범위에서 차이를 보이며, 결국 TCP/IP는 실제 구현의 표준, OSI는 이론적 기준점으로 함께 이해하는 것이 중요합니다.

---

## 참고

- [RFC 793 - Transmission Control Protocol](https://datatracker.ietf.org/doc/html/rfc793)
